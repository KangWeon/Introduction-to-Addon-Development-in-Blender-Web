---
pagetitle: 2-6. アドオンのソースコードを<br>複数ファイルへ分割する
subtitle: 2-6. アドオンのソースコードを<br>複数ファイルへ分割する
---

アドオンへ機能を追加し続けると、やがてソースコードのサイズが肥大化していきます。
ソースコードが肥大化することで管理が大変になってきたら、ソースコードを複数ファイルに分割することを検討しましょう。
本節では、アドオンのソースコードを複数のファイルへ分割する方法を紹介します。


# ソースコードを複数ファイルへ分割するメリット

前節までに紹介してきたサンプルアドオンのソースコードは、単一のファイルで構成されていました。
これまでのサンプルアドオンは、非常に単純な機能しか持たないアドオンでしたので、ソースコードの行数も比較的少なく、単一のファイルでも問題なく扱うことができました。
しかし本格的なアドオンは、本書で紹介しているアドオンよりも複雑な処理になる傾向があります。
複雑で規模が大きい処理の全てを単一のソースコードに書くと、あとでソースコードを修正したいときに修正箇所を見つけるのが大変です。

一般的に物事を分割して考えることは、複雑なことを理解するときの助けになります。
アドオンの開発においても同じことが言え、ソースコードを複数のファイルに分割することで管理しやすくなります。
例えば、あとからソースコードを修正するときに、単一のファイルで構成されているとファイル全体を見る必要があるのに対し、ファイルが適切に分割されていれば、関係のないファイルのソースコードを見る必要がなくなるため、目的の修正箇所を早く見つけることができるようになります。


# 作成するアドオンの仕様

* [2-2節](../chapter_02/02_Register_Multiple_Operation_Classes.html) で紹介したサンプルアドオンと同じ機能を持つ
* *[オブジェクト]* > *[X軸正方向へ並進移動]* の処理と *[オブジェクト]* > *[X軸負方向へ並進移動]* の処理を、複数のファイルへ分割する


# アドオンを作成する

[1-2節](../chapter_01/02_Use_Blender_Add-on.html) で説明したアドオン用フォルダに、ディレクトリ名 `sample_2-6` のディレクトリを作成します。
[1-5節](../chapter_01/05_Install_own_Add-on.html) を参考にして以下のソースコードを入力し、作成したディレクトリの下にファイル名をそれぞれ `__init__.py` , `forward_object.py` , `backward_object.py` として保存してください。


## \_\_init\_\_.py

[@include-source pattern="full" filepath="chapter_02/sample_2-6/__init__.py"]


## forward_object.py

[@include-source pattern="full" filepath="chapter_02/sample_2-6/forward_object.py"]


## backward_object.py

[@include-source pattern="full" filepath="chapter_02/sample_2-6/backward_object.py"]


# アドオンを使用する

## アドオンを有効化する

[1-5節](../chapter_01/05_Install_own_Add-on.html) を参考に作成したアドオンを有効化すると、コンソールウィンドウに以下の文字列が出力されます。

```
サンプル 2-6: アドオン『サンプル 2-6』が有効化されました。
```


## アドオンの機能を使用する

アドオンの機能は、[2-2節](../chapter_02/02_Register_Multiple_Operation_Classes.html) で紹介したサンプルと同じ機能ですので、ここでは説明を省きます。


## アドオンを無効化する

[1-5節](../chapter_01/05_Install_own_Add-on.html) を参考にして有効化したアドオンを無効化すると、コンソールウィンドウに以下の文字列が出力されます。

```
サンプル 2-6: アドオン『サンプル 2-6』が無効化されました。
```


# ソースコードの解説

## モジュールとパッケージ

ソースコードの解説に入る前に、Pythonのモジュールとパッケージの概念について理解しておく必要があります。

Pythonでは、クラスや関数、変数が定義された1つのファイルをモジュールといいます。
ソースコード内でモジュールをインポートすることによって、モジュールで定義したクラスや関数、変数が使用可能となります。

一方、複数のモジュールを1つにまとめたものをパッケージといいます。
Pythonでパッケージを作成するためには、ディレクトリを作成し、その配下にファイル `__init__.py` とパッケージ化するモジュール一式を置きます。
Pythonで一般的にパッケージを作る場合は `__init__.py` は空のファイルでもよいですが、あとで説明するようにBlenderでパッケージを作る場合は、特別な処理を記載する必要があります。

モジュール名はスクリプトのファイル名、パッケージ名は `__init__.py` とモジュール一式をまとめたディレクトリ名となります。
このことを踏まえると、本節のサンプルアドオンにおけるモジュールとパッケージの関係は、「sample_2-6パッケージには、forward_objectモジュールとbackward_objectモジュールが含まれる」となります。


## \_\_init\_\_.pyとは

本節で作成したサンプルアドオンのソースコードは、3つのファイルから構成されます。
3つのファイルのうち最も重要なファイルは、`__init__.py` です。
`__init__.py` には、アドオン有効化時に実行される処理やモジュールの読み込み処理を記載します。
（本節のサンプルでは、`forward_object` モジュールと `backward_object` モジュールを読み込む処理を記載します。）

一般的に `__init__.py` には、パッケージインポート時に呼び出される処理を記載することになっています。
`register` 関数や `unregister` 関数が定義され、これらの関数がアドオンの有効化/無効化時に呼び出されることから、アドオンの有効化はBlender上でのパッケージのインポート処理と同様であると考えることができます。

以降の解説では、`__init__.py` を中心に解説していきます。
`forward_object.py` と `backward_object.py` は [2-2節](../chapter_02/02_Register_Multiple_Operation_Classes.html) と同様のため、ここでは説明を省略します。


## モジュールのインポート

モジュールのインポートは `bpy` モジュールを読み込むときと同様、`import` 指示により行います。

```python
import forward_object
import backward_object
```

しかし、上記のコードを実行すると、アドオン有効化時に `forward_object` と `backward_object` が見つからないというエラーが発生します。
これは、Blenderが `forward_object` と `backward_object` の場所を知らないからです。

Blenderに `forward_object` と `backward_object` の場所を知らせるために、以下のように書き換えます。

```python
from . import enlarge_object
from . import reduce_object
```

`from .` を追加したことにより、`__init__.py` が置かれたディレクトリ、つまり自身のパッケージの中から2つのモジュール `forward_object` と `backward_object` を探すようになります。
上記のコードで、アドオン有効化時のエラーは出力されなくなりました。
しかし、もう1つやるべきことがあります。

[1-4節](../chapter_01/04_Understand_Install_Uninstall_Update_Add-on.html) では、Blenderの機能である『Reload Scripts』機能を用いて、Blenderを再起動せずにアドオンをアップデートする方法を紹介しました。
しかし、『Reload Scripts』機能を使っても、アドオンをアップデートできない場合があります。

結論から言うと、『Reload Scripts』機能を使ったときに、`__init__.py` の処理の中で、インポートしているモジュールの再読み込みに失敗していることが原因です。
`from  . import ...` を用いて、モジュールの再読み込みができると思う人もいるかもしれませんが、すでにインポートされているモジュールに対するインポート処理は無視されてしまいます。

この問題に対処するため、以下のようにインポート処理を書き換える必要があります。

[@include-source pattern="partial" filepath="chapter_02/sample_2-6/__init__.py" block="import_moudle"]

上記の処理を簡単に説明します。
最初のif文では、bpyモジュールが既にインポートされているかを判定します。
インポートされていなければ、Blender起動後に初めてアドオンが読み込まれたと判定し、関連するモジュールをインポートします。

一方、bpyモジュールがすでにインポートされていれば、Blenderが起動してから2回目以降の読み込みであると考えることができます。
このときは impモジュールを用いて、すでにインポートされているモジュールを再度読み込みます。
2回目以降の読み込みと判定されるのは、『Reload Scripts』機能によりアドオンが再度読み込まれたときに限定されるため、これは正しく動作します。

なお、bpyモジュールのインポートは、モジュールを読み込んだあとでなければなりません。
仮にbpyモジュールのインポート処理を、モジュールの読み込み処理の前に書いてしまうと、最初のif文で真と判定されてしまいます。


## グローバル変数bl_infoの作成

ファイル `__init__.py` には、グローバル変数 `bl_info` を定義する必要があります。
`bl_info` については、[2-1節](../chapter_02/01_Basic_of_Add-on_Development.html) ですでに説明しているため、ここでは説明を省略します。


## アドオン有効化・無効化時の処理

アドオンの有効化・無効化時に呼ばれる `register` 関数と `unregister` 関数についても、`__init__.py` に記載する必要があります。

`register` 関数と `unregister` 関数についても、[2-1節](../chapter_02/01_Basic_of_Add-on_Development.html) で説明した内容とほぼ同じですが、1点異なることがあります。

`register` 関数や `unregister` 関数の処理内で、`bpy.types.VIEW3D_MT_object.append` メソッドの引数に渡す `menu_fn` 関数を見てください。
`menu_fn` 関数の中で `self.layout.operator` メソッドが呼ばれているのは同じですが、引数に渡すクラス名の前にモジュール名が追加されています。
bpyモジュールと同様に `forward_object` や `backward_object` もモジュールであるため、モジュール内のクラスや関数などにアクセスするためのモジュール名を、指定してあげる必要があります。


## forward_object.backward_object.py

`forward_object.py` には `SAMPLE26_OT_ForwardXObject` クラス、`backward_object.py` には `SAMPLE26_OT_BackwardXObject` クラスが定義されています。
ソースコードの内容は、[2-1節](../chapter_02/01_Basic_of_Add-on_Development.html) と同じであるため、ここでは説明を省略します。


# まとめ

アドオンのソースコードを、複数のファイルに分割する方法を紹介しました。

ソースコードは規模が大きくなるにつれて管理しにくくなる傾向があるため、ある程度ソースコードの規模が大きくなってきたら、複数のファイルに分割することを検討すべきです。
ソースコードを分割する単位は、行数や機能などさまざまですが、筆者はアドオンを機能単位に分割するように心がけています。
これにより、機能にちなんだファイル名をつけることができるようになります。
また、機能ごとにモジュールが分かれるため、特定の機能を修正したいときに目的のソースコードを素早く見つけることができます。


## ポイント

* Pythonでは、クラスや関数、変数が定義された1つのスクリプトファイルをモジュールという
* Pythonでは、複数のモジュールを1つにまとめたものをパッケージという
* Pythonでパッケージを作成するためには、ディレクトリ配下に `__init__.py` とパッケージ化するモジュール一式を置く必要がある
* `__init__.py` には、アドオン有効化時に実行される処理やモジュールの読み込み処理を記載する
* アドオンを複数のファイルに分割する場合は、『Reload Scripts』機能への対応を忘れないようにしよう
* ソースコードの行数が大きくなると管理しにくくなる傾向があるため、ソースコードの規模が大きくなってきたら複数のファイルに分割することを検討しよう
